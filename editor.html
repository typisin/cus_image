<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CusImage Editor</title>
  <link rel="stylesheet" href="/styles.css">
  <link rel="stylesheet" href="/cutout.css">
  <link rel="icon" href="/favicon.svg?v=2" type="image/svg+xml">
  <link rel="shortcut icon" href="/favicon.svg?v=2" type="image/svg+xml">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    /* Modal Styles */
    .modal-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.5); z-index: 2000;
      display: flex; justify-content: center; align-items: center;
      backdrop-filter: blur(4px);
    }
    .modal-content.full-screen-modal {
      width: 90%; height: 90%; background: #fff; border-radius: 12px;
      display: flex; flex-direction: column; overflow: hidden;
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
    }
    .modal-header {
      padding: 1rem 1.5rem; border-bottom: 1px solid #e5e7eb;
      display: flex; justify-content: space-between; align-items: center;
    }
    .modal-header h2 { font-size: 1.25rem; font-weight: 600; color: #111827; margin: 0; }
    .close-btn {
      background: none; border: none; font-size: 2rem; line-height: 1;
      cursor: pointer; color: #6b7280;
    }
    .close-btn:hover { color: #111827; }
    .modal-body {
      flex: 1; overflow-y: auto; padding: 1.5rem; background: #f9fafb;
    }
    /* Layout adjustments for modal */
    .modal-layout-grid {
        display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; height: 100%;
    }
    .modal-pane {
        background: #fff; border-radius: 8px; padding: 1.5rem;
        border: 1px solid #e5e7eb; display: flex; flex-direction: column;
        height: 100%; overflow: hidden;
    }
    .modal-image-preview {
        flex: 1; background: #f3f4f6; border-radius: 8px;
        display: flex; justify-content: center; align-items: center;
        overflow: hidden; margin-top: 1rem;
    }
    .modal-image-preview img {
        max-width: 100%; max-height: 100%; object-fit: contain;
    }
    @media (max-width: 768px) {
        .modal-layout-grid { grid-template-columns: 1fr; overflow-y: auto; }
        .modal-pane { min-height: 400px; }
    }
    /* Full Screen Editor Layout Overrides */
    html, body { height: 100%; overflow: hidden; }
    .editor-mode .main {
        padding: 0;
        height: calc(100vh - 73px); /* Subtract header height */
        overflow: hidden;
    }
    .editor-mode .container {
        max-width: 100%;
        padding: 0;
        height: 100%;
    }
    .editor-workspace {
        margin-top: 0;
        height: 100%;
    }
    .editor-workspace .container {
        height: 100%;
    }
    .editor-grid {
        display: block;
        width: 100%;
        height: 100%;
        position: relative;
    }
    
    /* Toolbar (Left - Floating Top) */
    .editor-toolbar {
        position: absolute;
        top: 50%;
        left: 24px;
        transform: translateY(-50%);
        width: auto;
        min-width: 140px;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(8px);
        border: 1px solid rgba(229, 231, 235, 0.8);
        border-radius: 16px;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        padding: 0.75rem;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        align-items: stretch;
        z-index: 20;
    }

    .editor-toolbar.collapsed {
        transform: translateY(-50%) translateX(-110%);
        opacity: 0;
        pointer-events: none;
    }

    .editor-toolbar-toggle {
        position: absolute;
        left: 0;
        top: 50%;
        transform: translate(-50%, -50%);
        width: 28px;
        height: 48px;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(8px);
        border: 1px solid rgba(229, 231, 235, 0.8);
        border-radius: 0 12px 12px 0;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 21;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease, transform 0.2s ease;
    }
    .editor-toolbar.collapsed ~ .editor-toolbar-toggle {
        opacity: 1;
        pointer-events: auto;
    }
    
    .tool-btn {
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: flex-start;
        text-align: left;
        padding: 0.5rem 0.65rem;
        height: auto;
        min-height: 40px;
        width: 100%;
        border: 1px solid transparent;
        background: transparent;
        color: #4b5563;
        border-radius: 12px;
        gap: 10px;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        font-family: 'Inter', sans-serif;
    }
    .tool-btn:hover { 
        background: rgba(243, 244, 246, 0.8); 
        color: #111827;
        transform: translateY(-1px);
    }
    .tool-btn:active {
        transform: translateY(0);
    }
    .tool-btn .tool-icon { 
        width: 16px; 
        height: 16px; 
        margin-bottom: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
    }
    .tool-btn .tool-icon svg { width: 100%; height: 100%; }
    .tool-btn .tool-text { 
        font-size: 0.85rem; 
        font-weight: 500;
        white-space: nowrap;
    }
    
    /* Floating Tools (Right - Contextual) */
    .editor-floating-tools {
        position: absolute;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(8px);
        border: 1px solid rgba(229, 231, 235, 0.8);
        border-radius: 16px;
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        padding: 0.75rem;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        min-width: 120px;
        z-index: 30;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease, transform 0.2s ease;
        transform-origin: top left;
    }
    .editor-floating-tools.active {
        opacity: 1;
        pointer-events: auto;
    }
    
    /* Canvas (Center - Full Screen Bottom) */
    .editor-canvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        border: none;
        border-radius: 0;
        background: #f5f5f7;
        box-shadow: none;
        padding: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        z-index: 1;
    }
    .editor-canvas canvas {
        width: 100%;
        height: 100%;
        display: block;
        box-shadow: var(--shadow-sm);
    }
    /* Right Panel (Sliding Sidebar) */
    .editor-panel-right {
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        width: 300px;
        background: rgba(255, 255, 255, 0.98);
        backdrop-filter: blur(12px);
        border-left: 1px solid rgba(229, 231, 235, 0.8);
        padding: 1.5rem;
        display: flex;
        flex-direction: column;
        gap: 1rem;
        z-index: 50;
        overflow-y: auto;
        transform: translateX(100%);
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow: -4px 0 24px rgba(0,0,0,0.08);
    }
    .editor-panel-right.active {
        transform: translateX(0);
    } 
    
    /* Header adjustments */
    .header { padding: 0.75rem 0; border-bottom: 1px solid var(--gray-200); background: #fff; z-index: 20; position: relative; }
    .header .container { padding: 0 1.5rem; }
    
    /* Canvas upload empty state centered */
    .empty-state { z-index: 5; }
    
    @media (max-width: 768px) {
        .editor-toolbar {
            top: auto;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            flex-direction: row;
            width: auto;
            min-width: 0;
            padding: 0.5rem;
            border-radius: 100px;
            gap: 0.5rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        .tool-btn {
            padding: 0;
            width: 44px;
            height: 44px;
            justify-content: center;
            border-radius: 50%;
        }
        .tool-btn .tool-text { display: none; }
        .tool-btn .tool-icon { margin-right: 0; }
        .editor-panel-right { position: fixed; bottom: 0; left: 0; right: 0; height: 50%; transform: translateY(100%); transition: transform 0.3s; z-index: 100; border-top: 1px solid var(--gray-200); border-left: none; }
        .editor-panel-right.active { transform: translateY(0); }
    }

    /* Floating Bottom Toolbar (Merged) */
    .canvas-floating-toolbar {
        position: fixed;
        bottom: 32px;
        right: 32px; /* Page bottom-right */
        left: auto;
        transform: none;
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 12px; /* Slightly more padding for cleaner look */
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        box-shadow: 
            0 4px 6px -1px rgba(0, 0, 0, 0.1), 
            0 2px 4px -1px rgba(0, 0, 0, 0.06),
            0 12px 24px -4px rgba(0, 0, 0, 0.08),
            0 0 0 1px rgba(0,0,0,0.05);
        border-radius: 100px; /* Pill shape */
        z-index: 100;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .canvas-floating-toolbar:hover {
        box-shadow: 
            0 10px 15px -3px rgba(0, 0, 0, 0.1), 
            0 4px 6px -2px rgba(0, 0, 0, 0.05),
            0 20px 25px -5px rgba(0, 0, 0, 0.1),
            0 0 0 1px rgba(0,0,0,0.05);
        transform: translateY(-2px);
    }

    .toolbar-group {
        display: flex;
        align-items: center;
        gap: 6px;
    }

    .toolbar-divider {
        width: 1px;
        height: 20px;
        background: #e5e7eb;
        margin: 0 4px;
    }

    .toolbar-btn {
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        border: none;
        background: transparent;
        color: #4b5563;
        cursor: pointer;
        transition: all 0.2s ease;
        position: relative;
    }

    .toolbar-btn:hover {
        background: #f3f4f6;
        color: #111827;
    }
    
    .toolbar-btn:active {
        transform: scale(0.95);
    }
    
    .toolbar-btn.active {
        background: #eff6ff;
        color: #2563eb;
    }

    /* Replaced SVGs with Div-based CSS Icons */
    .icon-div {
        display: block;
        position: relative;
        pointer-events: none;
    }

    /* Undo Icon */
    .icon-undo {
        width: 16px; height: 16px;
        border: 2px solid currentColor;
        border-right: 0; border-top: 0;
        transform: rotate(45deg);
        margin-top: -2px;
        border-radius: 2px;
    }
    .icon-undo::after {
        content: ''; position: absolute;
        width: 10px; height: 10px;
        border: 2px solid currentColor;
        border-left: 0; border-bottom: 0;
        border-radius: 0 4px 0 0;
        top: -6px; right: -6px;
        transform: rotate(0deg);
    }
    /* PS-style Undo Icon (Curved Arrow Back) */
    .icon-undo-simple {
         width: 16px; height: 16px;
         position: relative;
    }
    .icon-undo-simple::before {
        content: ''; position: absolute;
        top: 2px; left: 2px;
        width: 12px; height: 12px;
        border: 2px solid currentColor;
        border-right: 0; border-top: 0;
        border-radius: 0 0 0 4px;
        transform: rotate(45deg);
    }
    .icon-undo-simple::after {
        content: ''; position: absolute;
        top: 5px; left: 0px;
        border: 4px solid transparent;
        border-right-color: currentColor;
        transform: rotate(0deg);
    }
    /* Better Curved Arrow approach using border-radius */
    .icon-undo-ps {
        width: 16px; height: 16px;
        position: relative;
        transform: scale(0.9);
    }
    .icon-undo-ps::before {
        /* Arrow head */
        content: ''; position: absolute;
        top: 4px; left: 0;
        border: 5px solid transparent;
        border-right-color: currentColor;
        transform: rotate(10deg);
    }
    .icon-undo-ps::after {
        /* Curved body */
        content: ''; position: absolute;
        top: 2px; left: 6px;
        width: 8px; height: 8px;
        border: 2px solid currentColor;
        border-left: 0; border-bottom: 0;
        border-radius: 0 8px 0 0;
        transform: rotate(-10deg);
    }

    /* PS-style Redo Icon (Curved Arrow Forward) */
    .icon-redo-simple {
         width: 16px; height: 16px;
         position: relative;
    }
    /* Better Curved Arrow approach */
    .icon-redo-ps {
        width: 16px; height: 16px;
        position: relative;
        transform: scale(0.9);
    }
    .icon-redo-ps::before {
        /* Arrow head */
        content: ''; position: absolute;
        top: 4px; right: 0;
        border: 5px solid transparent;
        border-left-color: currentColor;
        transform: rotate(-10deg);
    }
    .icon-redo-ps::after {
        /* Curved body */
        content: ''; position: absolute;
        top: 2px; right: 6px;
        width: 8px; height: 8px;
        border: 2px solid currentColor;
        border-right: 0; border-bottom: 0;
        border-radius: 8px 0 0 0;
        transform: rotate(10deg);
    }

    /* Zoom Out (Minus) */
    .icon-zoom-out {
        width: 14px; height: 2px;
        background: currentColor;
        border-radius: 1px;
    }

    /* Zoom In (Plus) */
    .icon-zoom-in {
        width: 14px; height: 14px;
        position: relative;
    }
    .icon-zoom-in::before, .icon-zoom-in::after {
        content: ''; position: absolute;
        background: currentColor; border-radius: 1px;
        left: 50%; top: 50%; transform: translate(-50%, -50%);
    }
    .icon-zoom-in::before { width: 14px; height: 2px; }
    .icon-zoom-in::after { width: 2px; height: 14px; }

    /* Fit Screen (Frame) */
    .icon-fit {
        width: 16px; height: 16px;
        position: relative;
    }
    .icon-fit::before {
        content: ''; position: absolute; inset: 0;
        border: 2px solid currentColor;
        border-radius: 4px;
    }
    .icon-fit::after {
        content: ''; position: absolute; inset: 4px;
        background: currentColor;
        opacity: 0.3;
        border-radius: 1px;
    }

    /* Layers (PS Style - Two Overlapping Diamonds) */
    .icon-layers {
        width: 16px; height: 16px;
        position: relative;
    }
    /* Bottom Diamond */
    .icon-layers::before {
        content: ''; position: absolute;
        width: 10px; height: 10px;
        border: 2px solid currentColor;
        top: 6px; left: 3px;
        transform: rotate(45deg) scaleY(0.6);
    }
    /* Top Diamond */
    .icon-layers::after {
        content: ''; position: absolute;
        width: 10px; height: 10px;
        border: 2px solid currentColor;
        background: white; /* Cover the line below */
        top: 2px; left: 3px;
        transform: rotate(45deg) scaleY(0.6);
        z-index: 1;
    }

    .toolbar-btn.with-label {
        width: auto;
        padding: 0 12px;
        border-radius: 20px;
        gap: 6px;
    }
    
    .toolbar-btn.with-label .btn-label {
        /* User requested to delete span, but keeping class just in case of revert, hidden via display none if needed */
        display: none; 
    }

    .toolbar-text {
        /* User requested to delete span */
        display: none;
    }

    @media (max-width: 768px) {
        .canvas-floating-toolbar {
            bottom: 24px;
            right: 16px;
            left: auto;
            transform: none;
            width: auto;
            justify-content: flex-end;
            overflow-x: visible;
            border-radius: 100px;
        }
    }

    /* Layer Popover */
    .layer-popover {
        position: absolute;
        bottom: 80px; /* Toolbar bottom(32) + height(approx 40) + gap(8) */
        right: 32px; /* Aligned with toolbar right */
        width: 280px;
        background: rgba(255, 255, 255, 0.98);
        backdrop-filter: blur(16px);
        -webkit-backdrop-filter: blur(16px);
        border-radius: 16px;
        box-shadow: 
            0 10px 15px -3px rgba(0, 0, 0, 0.1), 
            0 4px 6px -2px rgba(0, 0, 0, 0.05),
            0 0 0 1px rgba(0,0,0,0.05);
        border: none; /* using shadow border */
        display: flex;
        flex-direction: column;
        overflow: hidden;
        z-index: 101; /* Above toolbar */
        animation: popoverFadeIn 0.2s cubic-bezier(0.16, 1, 0.3, 1);
        transform-origin: bottom right; /* Animate from bottom right */
    }
    
    @keyframes popoverFadeIn {
        from { opacity: 0; transform: translateY(8px) scale(0.96); }
        to { opacity: 1; transform: translateY(0) scale(1); }
    }
    .layer-header {
        padding: 12px 16px;
        border-bottom: 1px solid #f3f4f6;
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: white;
    }
    .layer-list {
        max-height: 300px;
        overflow-y: auto;
        padding: 8px;
        background: #f9fafb;
    }
    .layer-item {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 8px;
        background: white;
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        margin-bottom: 8px;
        cursor: pointer;
        transition: all 0.2s;
    }
    .layer-item:hover {
        border-color: #d1d5db;
    }
    .layer-item.selected {
        border-color: #2563eb;
        box-shadow: 0 0 0 1px #2563eb;
    }
    .layer-thumb {
        width: 40px;
        height: 40px;
        border-radius: 4px;
        object-fit: cover;
        background: #eee;
        border: 1px solid #e5e7eb;
    }
    .layer-info {
        flex: 1;
        min-width: 0;
    }
    .layer-name {
        font-size: 0.875rem;
        font-weight: 500;
        color: #374151;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    .layer-actions {
        display: flex;
        gap: 4px;
    }
    .layer-action-btn {
        padding: 4px;
        border-radius: 4px;
        color: #6b7280;
        background: transparent;
        border: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    .layer-action-btn:hover {
        background: #f3f4f6;
        color: #111827;
    }
  </style>


  <script>(function(){var h=location.hostname;var isLocal=/^(localhost|127\.0\.0\.1)$/.test(h);if(!isLocal){var s=document.createElement('script');s.defer=true;s.src='/_vercel/insights/script.js';document.head.appendChild(s);}})();</script>
</head>
<body class="editor-mode">
  <!-- Image Describer Modal moved into body for proper stacking over aside -->
  <div id="describerModal" class="modal-overlay" style="display: none;">
    <div class="modal-content full-screen-modal">
      <div class="modal-header">
        <h2>AI Image Describer</h2>
        <button id="btnCloseDescriberModal" class="close-btn">&times;</button>
      </div>
      <div class="modal-body">
         <div class="modal-layout-grid">
             <div class="modal-pane">
                 <h4 style="font-size: 1.125rem; font-weight: 600; color: var(--gray-900); margin-bottom: 1rem;">Original Image</h4>
                 <div class="modal-image-preview">
                     <img id="describerPreviewImg" alt="Original Image">
                 </div>
             </div>
             <div class="modal-pane">
                 <div class="settings-actions" style="margin-bottom: 1.5rem;">
                     <label for="describerStyle" style="font-size:0.9rem;color:var(--gray-700);display:block;margin-bottom:0.5rem;">Prompt Style</label>
                     <select id="describerStyle" style="height:40px;padding:0 0.75rem;border:1px solid var(--gray-300);border-radius:0.375rem;width:100%;">
                         <option value="Brief">Brief</option>
                         <option value="In detail">In detail</option>
                         <option value="Vivid">Vivid</option>
                         <option value="Abstractly">Abstractly</option>
                     </select>
                 </div>
                 <div class="prompts-box" style="margin-bottom: 1.5rem; position: relative; flex: 1; display: flex; flex-direction: column;">
                     <label style="font-size:0.9rem;color:var(--gray-700);display:block;margin-bottom:0.5rem;">Generated Description</label>
                     <textarea id="describerOutput" style="width:100%;flex:1;padding:0.75rem;border:1px solid var(--gray-300);border-radius:0.375rem;resize:none;" placeholder="Description will be shown here..."></textarea>
                     <div id="describerLoading" class="loading-overlay" style="display: none; position: absolute; inset: 0; justify-content: center; align-items: center; background: rgba(255,255,255,0.8); z-index: 10;">
                         <div class="loading-spinner"></div>
                         <p>Generating...</p>
                     </div>
                 </div>
                 <div class="panel-actions" style="display:flex;flex-direction:column;gap:0.75rem;">
                     <button class="btn btn-primary" id="btnDescriberGenerate" style="justify-content:center;">Generate Description</button>
                     <div style="display:grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">
                         <button class="btn btn-secondary" id="btnDescriberCopy" style="justify-content:center;">Copy</button>
                         <button class="btn btn-secondary" id="btnDescriberClear" style="justify-content:center;">Clear</button>
                     </div>
                 </div>
             </div>
         </div>
      </div>
    </div>
  </div>
  <canvas id="analysisCanvas" style="display:none;"></canvas>
  <main class="main">
    <div class="container">
      <section class="editor-workspace" aria-label="Image Editor">
        <div class="container">
          <div class="editor-grid">
            <!-- Left Toolbar -->
            <aside class="editor-toolbar">
                <button id="toolImage" class="tool-btn" title="Add Image">
                    <div class="tool-icon"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg></div>
                    <span class="tool-text">Image</span>
                </button>
                <button id="toolText" class="tool-btn" title="Add Text">
                    <div class="tool-icon"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 7V4h16v3"></path><path d="M9 20h6"></path><path d="M12 4v16"></path></svg></div>
                    <span class="tool-text">Text</span>
                </button>
                
                <div style="height: 1px; background: var(--gray-200); width: 100%; margin: 0.5rem 0;"></div>
                <button id="toolbarCollapse" class="tool-btn" title="Collapse Toolbar">
                    <div class="tool-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg></div>
                    <span class="tool-text">Collapse</span>
                </button>
            </aside>
            <button id="toolbarToggle" class="editor-toolbar-toggle" aria-label="Expand Toolbar" title="Expand Toolbar">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>
            </button>

            <div class="editor-canvas" id="editorCanvasWrap" style="touch-action: none;">
              <div id="emptyState" class="empty-state" aria-live="polite">
                <div class="upload-icon" aria-hidden="true">
                  <svg width="64" height="64" viewBox="0 0 24 24" fill="none">
                    <path d="M12 2L12 14M12 2L8 6M12 2L16 6" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                    <path d="M4 16L4 18C4 19.1046 4.89543 20 6 20L18 20C19.1046 20 20 19.1046 20 18L20 16" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                  </svg>
                </div>
                <h3 class="upload-title">Upload image to start editing</h3>
                <p class="upload-text">Click the button or drag and drop an image here</p>
                <div class="download-actions">
                  <button id="btnUploadCanvas" class="btn btn-secondary" aria-controls="editorCanvas">Upload Image</button>
                </div>
              </div>
              <input id="fileInput" type="file" accept="image/*" hidden>
              <canvas id="editorCanvas" width="960" height="540" aria-label="Image editor canvas" style="touch-action: none;"></canvas>
            </div>

            <div id="canvasBottomToolbar" class="canvas-floating-toolbar" aria-label="Canvas Toolbar">
                <!-- History Group -->
                <div class="toolbar-group">
                    <button id="btnUndo" class="toolbar-btn" title="Undo" aria-label="Undo">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M9 14l-5-5 5-5"></path>
                            <path d="M4 9h7a7 7 0 0 1 7 7"></path>
                        </svg>
                    </button>
                    <button id="btnRedo" class="toolbar-btn" title="Redo" aria-label="Redo">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M15 10l5 5-5 5"></path>
                            <path d="M20 15h-7a7 7 0 0 1-7-7"></path>
                        </svg>
                    </button>
                </div>

                <div class="toolbar-divider"></div>

                <!-- Zoom Group -->
                <div class="toolbar-group">
                    <button id="btnZoomOut" class="toolbar-btn" title="Zoom Out" aria-label="Zoom Out">
                        <div class="icon-div icon-zoom-out"></div>
                    </button>
                    <button id="btnZoomIn" class="toolbar-btn" title="Zoom In" aria-label="Zoom In">
                        <div class="icon-div icon-zoom-in"></div>
                    </button>
                </div>

                <div class="toolbar-divider"></div>

                <!-- View Actions -->
                <div class="toolbar-group">
                    <button id="btnFitScreen" class="toolbar-btn" title="Fit to Screen" aria-label="Show All">
                         <div class="icon-div icon-fit"></div>
                    </button>
                </div>

                <div class="toolbar-divider"></div>

                <!-- Layers -->
                <div class="toolbar-group">
                    <button id="btnShowLayers" class="toolbar-btn" title="Layers" aria-label="Layers">
                        <div class="icon-div icon-layers"></div>
                    </button>
                </div>
            </div>

            <!-- Layer Popover (Replaces Side Panel) -->
            <div id="layerPopover" class="layer-popover" style="display: none;">
                <div class="layer-header">
                    <span style="font-weight: 600; font-size: 1rem; color: #111827;">图层</span>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span style="font-size: 0.85rem; color: #6b7280;">不透明度</span>
                        <div style="background: #f3f4f6; padding: 2px 8px; border-radius: 6px; font-size: 0.85rem; font-weight: 500; color: #374151;" id="layerOpacityDisplay">100 %</div>
                    </div>
                </div>
                <div id="layersList" class="layer-list">
                    <!-- Layer Items will be injected here -->
                </div>
            </div>

            <!-- Floating Tools (right of canvas) -->
            <div class="editor-floating-tools" aria-label="Floating Tools">
                <button id="btnCutout" class="tool-btn" title="AI Cutout">
                    <div class="tool-icon"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 3v18"></path><circle cx="18" cy="6" r="3"></circle><circle cx="18" cy="18" r="3"></circle><path d="M18 9v6"></path></svg></div>
                    <span class="tool-text">Cutout</span>
                </button>
                <button id="btnImageDescriber" class="tool-btn" title="Image Describer">
                    <div class="tool-icon"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg></div>
                    <span class="tool-text">Describe</span>
                </button>
            </div>
          </div>
          
        </div>
      </section>
    </div>
  </main>

  <script>
  (function(){
    var fileInput = document.getElementById('fileInput');
    var btnUploadCanvas = document.getElementById('btnUploadCanvas');
    var canvasWrap = document.getElementById('editorCanvasWrap');
    var toolbar = document.querySelector('.editor-floating-tools');
    var emptyState = document.getElementById('emptyState');
    var canvas = document.getElementById('editorCanvas');
    var toolImage = document.getElementById('toolImage');
    var toolText = document.getElementById('toolText');
    
    var toolbarLeft = document.querySelector('.editor-toolbar');
    var btnToolbarCollapse = document.getElementById('toolbarCollapse');
    var btnToolbarToggle = document.getElementById('toolbarToggle');
    var panelRight = document.getElementById('editorPanelRight');
    var workspace = document.querySelector('.editor-workspace');
    var btnCutout = document.getElementById('btnCutout');
    var btnDescriber = document.getElementById('btnImageDescriber');
    var btnUndo = document.getElementById('btnUndo');
    var btnRedo = document.getElementById('btnRedo');
    var btnZoomOut = document.getElementById('btnZoomOut');
    var btnZoomIn = document.getElementById('btnZoomIn');
    var btnShowLayers = document.getElementById('btnShowLayers');
    
    if (!canvas) return; var ctx = canvas.getContext('2d');

    // State
    var img = null; var imgW = 0, imgH = 0; 
    var currentFile = null; // Store the original file object
    // View Transform
    var scale = 1; var panX = 0, panY = 0; var baseFitScale = 1;
    // Image Transform & Selection
    var imgState = { x: 0, y: 0, scale: 1, angle: 0 };
    var isSelected = false;
    var isProcessing = false; // Processing state
    
    var dragging = false; var draggingImage = false; var lastX = 0, lastY = 0;
    var draggingResize = false; var draggingRotate = false; var dragMeta = null;
    var drawMode = false; var drawing = false;
    var layers = [];
    var selectedLayerIdx = null;
    var currentPathLayerIdx = null;
    var history = [];
    var future = [];
    var currentFileId = null;

    function clear(){ ctx.clearRect(0,0,canvas.width,canvas.height); }
    
    function resizeCanvas(){
      var rect = canvasWrap.getBoundingClientRect();
      var dpr = window.devicePixelRatio || 1;
      canvas.style.width = rect.width + 'px';
      canvas.style.height = rect.height + 'px';
      canvas.width = Math.max(1, Math.floor(rect.width * dpr));
      canvas.height = Math.max(1, Math.floor(rect.height * dpr));
    }
    
    function draw(){
      clear();
      ctx.fillStyle = '#f5f5f7';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.strokeStyle = '#e5e7eb';
      ctx.strokeRect(0.5,0.5,canvas.width-1,canvas.height-1);
      
      var cx = canvas.width/2, cy = canvas.height/2;
      
      // View Transform
      var viewScale = baseFitScale * scale;
      
      if (img) {
        ctx.save();
        ctx.translate(cx + panX, cy + panY);
        ctx.scale(viewScale, viewScale);
        
        // Image Transform
        ctx.save();
        ctx.translate(imgState.x, imgState.y);
        ctx.rotate(imgState.angle * Math.PI / 180);
        ctx.scale(imgState.scale, imgState.scale);
        
        ctx.drawImage(img, -imgW/2, -imgH/2, imgW, imgH);
        
        if (isSelected && !isProcessing) {
          ctx.strokeStyle = '#2563eb';
          ctx.lineWidth = 2 / (viewScale * imgState.scale);
          ctx.strokeRect(-imgW/2, -imgH/2, imgW, imgH);

          var handleSize = 8 / (viewScale * imgState.scale);
          ctx.fillStyle = '#ffffff';
          ctx.strokeStyle = '#2563eb';
          var hw = imgW/2, hh = imgH/2;
          var handles = [
            {x: -hw, y: -hh}, {x: hw, y: -hh},
            {x: hw, y: hh}, {x: -hw, y: hh}
          ];
          handles.forEach(function(h){
             ctx.fillRect(h.x - handleSize/2, h.y - handleSize/2, handleSize, handleSize);
             ctx.strokeRect(h.x - handleSize/2, h.y - handleSize/2, handleSize, handleSize);
          });

          var rotOffset = 20 / (viewScale * imgState.scale);
          var rx = 0;
          var ry = -hh - rotOffset;
          ctx.beginPath();
          ctx.moveTo(0, -hh);
          ctx.lineTo(rx, ry);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(rx, ry, handleSize/1.5, 0, Math.PI*2);
          ctx.fill();
          ctx.stroke();
        }

        // Processing Loading State
        if (isProcessing) {
          ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
          ctx.fillRect(-imgW/2, -imgH/2, imgW, imgH);
          
          ctx.fillStyle = '#2563eb';
          ctx.font = 'bold 24px Inter, sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          // Scale text down if image is small? For now fixed size might be okay or relative.
          // Let's use a scale-independent size if possible, but canvas text scales with context.
          // To keep text readable, we might want to invert the scale?
          // For simplicity:
          ctx.save();
          var textScale = 1 / (viewScale * imgState.scale);
          ctx.scale(textScale, textScale);
          ctx.fillText('Processing...', 0, 0);
          ctx.restore();
        }

        ctx.restore(); // End Image Transform
        ctx.restore(); // End View Transform
      }

      // Layers (follow image transform)
      ctx.save();
      ctx.translate(cx + panX, cy + panY);
      ctx.scale(viewScale, viewScale);
      ctx.translate(imgState.x, imgState.y);
      ctx.rotate(imgState.angle * Math.PI / 180);
      ctx.scale(imgState.scale, imgState.scale);
      ctx.lineWidth = 2 / (viewScale * imgState.scale);
      for (var i=0;i<layers.length;i++){
        var L = layers[i]; if (!L.visible) continue; var alpha = typeof L.opacity==='number'?L.opacity:1; ctx.save(); ctx.globalAlpha = alpha;
        if (L.type === 'board') {
          ctx.fillStyle = (L.payload && L.payload.bgColor) || '#ffffff';
          ctx.fillRect(-imgW/2, -imgH/2, imgW, imgH);
        } else if (L.type === 'path') {
          var path = L.payload && L.payload.points || [];
          if (path.length >= 2) { ctx.strokeStyle = (L.payload && L.payload.color) || '#2563eb'; ctx.beginPath(); for (var j=0;j<path.length;j++){ var p = path[j]; var x = p.x - imgW/2; var y = p.y - imgH/2; if (j===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); } ctx.stroke(); }
        } else if (L.type === 'text') {
          var t = L.payload || {}; ctx.fillStyle = t.color || '#111827'; ctx.font = t.font || '16px Inter, sans-serif'; var x = (t.x||imgW/2) - imgW/2; var y = (t.y||imgH/2) - imgH/2; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(t.text || 'Text', x, y);
        } else if (L.type === 'image') {
          var im = L.payload && L.payload.image; var w = L.payload && L.payload.w; var h = L.payload && L.payload.h; var x0 = (L.payload && L.payload.x)|| (imgW/2); var y0 = (L.payload && L.payload.y)|| (imgH/2); if (im && w && h){ ctx.save(); var x = x0 - imgW/2; var y = y0 - imgH/2; ctx.drawImage(im, x - w/2, y - h/2, w, h); ctx.restore(); }
        }
        ctx.restore();
      }
      ctx.restore();
      
      // Update floating tools position if active
      if (isSelected) {
        positionFloatingTools();
      }
      
      // Update Zoom Percentage
      var zp = document.getElementById('zoomPercentage');
      if (zp) {
         zp.textContent = Math.round(scale * 100) + ' %';
      }
    }

    function fitBase(){ if (!img) return; baseFitScale = Math.min((canvas.width-40)/imgW, (canvas.height-40)/imgH); if(baseFitScale>1) baseFitScale=1; }
    function reset(){ 
      if (!img) { scale = 1; panX = 0; panY = 0; draw(); return; } 
      scale = 1; panX = 0; panY = 0; 
      imgState = { x: 0, y: 0, scale: 1, angle: 0 };
      isSelected = false;
      isProcessing = false;
      toggleSidebar(false);
      fitBase(); 
      draw(); 
    }

    function loadDataUrl(dataUrl){ var im = new Image(); im.onload = async function(){ img = im; imgW = im.naturalWidth; imgH = im.naturalHeight; emptyState.style.display = 'none'; layers = []; selectedLayerIdx = null; currentPathLayerIdx = null; resizeCanvas(); fitBase(); draw(); renderLayersPanel(); pushHistory(); try { if (!currentFile && typeof dataUrl === 'string' && dataUrl.startsWith('data:')) { var arr = dataUrl.split(','); var mime = arr[0].match(/:(.*?);/)[1]; var bstr = atob(arr[1]); var n = bstr.length; var u8 = new Uint8Array(n); for (var i=0;i<n;i++){ u8[i]=bstr.charCodeAt(i); } var blob = new Blob([u8], { type: mime }); currentFile = new File([blob], 'image.' + (mime.split('/')[1]||'png'), { type: mime }); } if (currentFile && !currentFileId) { try { currentFileId = await uploadToServer(currentFile); } catch(_){} } } catch(_){} }; im.src = dataUrl; }
    function loadFile(file){ 
      currentFile = file; 
      var fr = new FileReader(); 
      fr.onload = function(){ loadDataUrl(fr.result); (async function(){ try { currentFileId = await uploadToServer(currentFile); } catch(_){} })(); }; 
      fr.readAsDataURL(file); 
    }

    // Backend API Helpers
    async function uploadToServer(file) {
      console.log('Uploading file...');
      var fd = new FormData();
      fd.append('file', file);
      
      try {
        var res = await fetch('/api/coze/upload', { method: 'POST', body: fd });
        if (!res.ok) {
           var txt = await res.text();
           throw new Error('Upload failed: ' + res.status + ' ' + txt);
        }
        var json = await res.json();
        return json.file_id;
      } catch (e) {
        console.error(e);
        throw e;
      }
    }

    async function runCutoutWorkflow(fileId) {
       console.log('Running cutout workflow...', fileId);
       var payload = { file_id: fileId };
       try {
         var res = await fetch('/api/coze/workflow/run', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
         });
         if (!res.ok) {
            var txt = await res.text();
            throw new Error('Workflow failed: ' + res.status + ' ' + txt);
         }
         var json = await res.json();
         return json;
       } catch (e) {
         console.error(e);
         throw e;
       }
    }

   function toggleSidebar(show) {
      if (toolbar) {
        if (show) {
           toolbar.classList.add('active');
           positionFloatingTools();
        } else {
           toolbar.classList.remove('active');
        }
      }
    }
    
    function updatePanelPosition() { /* deprecated */ }

    function positionFloatingTools(){
      // Position the contextual floating tools (Cutout/Describe) near the selected object
      if (!toolbar || !isSelected || !img || !toolbar.classList.contains('active')) return;
      
      // ... Existing logic for contextual tools ...
      var viewScale = baseFitScale * scale;
      var cx = canvas.width / 2 + panX;
      var cy = canvas.height / 2 + panY;

      var hw = imgW / 2;
      var hh = imgH / 2;
      var corners = [
        {x: -hw, y: -hh},
        {x: hw, y: -hh},
        {x: hw, y: hh},
        {x: -hw, y: hh}
      ];

      var rad = imgState.angle * Math.PI / 180;
      var cos = Math.cos(rad);
      var sin = Math.sin(rad);

      var minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;

      for (var i=0;i<corners.length;i++){
        var p = corners[i];
        var sx = p.x * imgState.scale;
        var sy = p.y * imgState.scale;
        var rx = sx * cos - sy * sin;
        var ry = sx * sin + sy * cos;
        var tx = rx + imgState.x;
        var ty = ry + imgState.y;
        var screenX = tx * viewScale + cx;
        var screenY = ty * viewScale + cy;
        if (screenX < minX) minX = screenX;
        if (screenX > maxX) maxX = screenX;
        if (screenY < minY) minY = screenY;
        if (screenY > maxY) maxY = screenY;
      }

      var rect = canvas.getBoundingClientRect();
      var wrapRect = canvasWrap.getBoundingClientRect();
      var cssScaleX = rect.width / canvas.width;
      var cssScaleY = rect.height / canvas.height;
      var canvasLeft = rect.left - wrapRect.left;
      var canvasTop = rect.top - wrapRect.top;

      var GAP = 16;
      var left = canvasLeft + (maxX * cssScaleX) + GAP;
      var centerY = canvasTop + ((minY + maxY) / 2) * cssScaleY;
      var top = centerY;

      var tW = toolbar.offsetWidth || 200;
      var tH = toolbar.offsetHeight || 120;

      if (left + tW > wrapRect.width - 10) left = Math.max(10, wrapRect.width - tW - 10);
      if (top + tH/2 > wrapRect.height - 10) top = Math.max(tH/2 + 10, wrapRect.height - 10);
      if (top - tH/2 < 10) top = tH/2 + 10;

      toolbar.style.left = left + 'px';
      toolbar.style.top = top + 'px';
      toolbar.style.transform = 'translateY(-50%)';
    }
    
    btnUploadCanvas && btnUploadCanvas.addEventListener('click', function(){ fileInput && fileInput.click(); });
    fileInput && fileInput.addEventListener('change', function(e){ var f = e.target.files && e.target.files[0]; if (!f) return; if (!img) { loadFile(f); } else { loadImageLayer(f); } });
    toolImage && toolImage.addEventListener('click', function(){ fileInput && fileInput.click(); });
    toolText && toolText.addEventListener('click', function(){ if (!img) return; var cx = imgW/2, cy = imgH/2; layers.push({ type:'text', name:'Text', visible:true, opacity:1, payload:{ text:'Text', x:cx, y:cy, color:'#111827', font:'18px Inter, sans-serif' } }); selectedLayerIdx = layers.length-1; draw(); renderLayersPanel(); pushHistory(); });
    

    btnToolbarCollapse && btnToolbarCollapse.addEventListener('click', function(){
      if (!toolbarLeft) return;
      toolbarLeft.classList.add('collapsed');
    });
    btnToolbarToggle && btnToolbarToggle.addEventListener('click', function(){
      if (!toolbarLeft) return;
      toolbarLeft.classList.remove('collapsed');
    });
    
    // Feature Actions
    function simulateProcessing(btn, callback) {
      if (btn.classList.contains('loading')) return;
      btn.classList.add('loading');
      btn.disabled = true;
      setTimeout(function(){
        btn.classList.remove('loading');
        btn.disabled = false;
        callback();
      }, 1500);
    }

    btnCutout && btnCutout.addEventListener('click', async function(){
      if (!img) return;
      if (!currentFile) {
         if (img.src && img.src.startsWith('blob:')) { try { var r = await fetch(img.src); currentFile = await r.blob(); } catch(_){} }
         else if (img.src && img.src.startsWith('data:')) { try { var arr = img.src.split(','); var mime = arr[0].match(/:(.*?);/)[1]; var bstr = atob(arr[1]); var n = bstr.length; var u8 = new Uint8Array(n); for (var i=0;i<n;i++){ u8[i]=bstr.charCodeAt(i); } var blob = new Blob([u8], { type: mime }); currentFile = new File([blob], 'image.' + (mime.split('/')[1]||'png'), { type: mime }); } catch(_){} }
         if (!currentFile) { alert('Cannot process this image (missing file data). Please re-upload.'); return; }
      }

      var btn = this;
      if (btn.classList.contains('loading')) return;
      btn.classList.add('loading');
      btn.disabled = true;
      
      // Start processing visual state
      isProcessing = true;
      draw();
      
      try {
        var fileId = await uploadToServer(currentFile);
        
        // 2. Run Workflow
        var result = await runCutoutWorkflow(fileId);
        
        // 3. Extract Image URL
        var cutoutUrl = null;
        if (result && result.data) {
             var data = result.data;
             if (typeof data === 'string') {
                 try { data = JSON.parse(data); } catch(e){}
             }
             if (data.output && data.output.image_url) cutoutUrl = data.output.image_url;
             else if (data.image_url) cutoutUrl = data.image_url;
             else if (data.url) cutoutUrl = data.url;
             else if (typeof data.output === 'string' && data.output.startsWith('http')) cutoutUrl = data.output;
        }
        
        if (cutoutUrl) {
            // 4. Load Result Image
            try {
                // Fetch blob to keep it as a File for future operations
                var resp = await fetch(cutoutUrl);
                var blob = await resp.blob();
                var newFile = new File([blob], "cutout.png", { type: "image/png" });
                loadFile(newFile);
                try { currentFileId = await uploadToServer(newFile); } catch(_){}
            } catch (e) {
                console.warn('Failed to fetch blob, loading URL directly', e);
                loadDataUrl(cutoutUrl);
                try { var r2 = await fetch(cutoutUrl); var b2 = await r2.blob(); currentFile = new File([b2], "cutout.png", { type: b2.type || "image/png" }); currentFileId = await uploadToServer(currentFile); } catch(_) { currentFile = null; }
            }
        } else {
            alert('Could not get result image from workflow.');
        }
        
      } catch (err) {
        console.error(err);
        alert('Cutout failed: ' + err.message);
      } finally {
        isProcessing = false;
        btn.classList.remove('loading');
        btn.disabled = false;
        // draw() will be called by loadFile/loadDataUrl if successful, 
        // but if failed, we need to redraw to remove loading state.
        draw();
      }
    });

    btnDescriber && btnDescriber.addEventListener('click', function(){
      if (!img) {
          alert('Please upload an image first.');
          return;
      }
      // Show Modal
      var describerModal = document.getElementById('describerModal');
      var describerPreviewImg = document.getElementById('describerPreviewImg');
      var describerOutput = document.getElementById('describerOutput');
      var describerLoading = document.getElementById('describerLoading');
      
      if (describerModal) {
          describerModal.style.display = 'flex';
          // Set Preview Image
          if (describerPreviewImg && img) {
               describerPreviewImg.src = img.src;
          }
          // Reset fields
          if (describerOutput) describerOutput.value = '';
          if (describerLoading) describerLoading.style.display = 'none';
      }
    });

    // --- Image Describer Helper Functions ---
    var analysisCanvas = document.getElementById('analysisCanvas');
    
    function rgbToHsl(r, g, b) {
        r /= 255; g /= 255; b /= 255;
        var max = Math.max(r,g,b), min = Math.min(r,g,b);
        var h, s, l = (max + min) / 2;
        if (max === min) { h = 0; s = 0; }
        else {
            var d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) { case r: h = (g - b) / d + (g < b ? 6 : 0); break; case g: h = (b - r) / d + 2; break; case b: h = (r - g) / d + 4; break; }
            h = h * 60;
        }
        return { h: h, s: s, l: l };
    }
    
    function hueToName(h, s, l) {
        if (s < 0.2) { if (l < 0.25) return 'black'; if (l > 0.75) return 'white'; return 'gray'; }
        if (h < 15 || h >= 345) return 'red'; if (h < 45) return 'orange'; if (h < 75) return 'yellow'; if (h < 165) return 'green'; if (h < 195) return 'cyan'; if (h < 255) return 'blue'; if (h < 285) return 'purple'; if (h < 330) return 'magenta'; return 'pink';
    }
    
    function analyze(imgEl) {
        if (!analysisCanvas) return 'Analysis unavailable';
        var w = imgEl.naturalWidth; var h = imgEl.naturalHeight; 
        if (!w || !h) return 'Image not loaded';
        var maxSide = 256; var scale = Math.min(1, maxSide / Math.max(w, h)); 
        var cw = Math.max(1, Math.floor(w * scale)); var ch = Math.max(1, Math.floor(h * scale));
        analysisCanvas.width = cw; analysisCanvas.height = ch; 
        var ctx = analysisCanvas.getContext('2d'); 
        ctx.drawImage(imgEl, 0, 0, cw, ch); 
        var data = ctx.getImageData(0, 0, cw, ch).data;
        var colorCounts = {}; var total = 0; var sumLuma = 0; var sumR = 0, sumG = 0, sumB = 0; var sumR2 = 0, sumG2 = 0, sumB2 = 0;
        for (var y = 0; y < ch; y += 2) { for (var x = 0; x < cw; x += 2) { var i = (y * cw + x) * 4; var r = data[i], g = data[i+1], b = data[i+2]; var hsl = rgbToHsl(r,g,b); var name = hueToName(hsl.h, hsl.s, hsl.l); colorCounts[name] = (colorCounts[name] || 0) + 1; total++; var luma = 0.2126 * r + 0.7152 * g + 0.0722 * b; sumLuma += luma; sumR += r; sumG += g; sumB += b; sumR2 += r*r; sumG2 += g*g; sumB2 += b*b; } }
        var avgLuma = sumLuma / total / 255; var meanR = sumR / total, meanG = sumG / total, meanB = sumB / total; var varR = sumR2 / total - meanR*meanR; var varG = sumG2 / total - meanG*meanG; var varB = sumB2 / total - meanB*meanB; var colorfulness = Math.sqrt(Math.max(0, varR) + Math.max(0, varG) + Math.max(0, varB)) / 255;
        var gradSum = 0; var gradCount = 0; for (var y2 = 1; y2 < ch-1; y2 += 2) { for (var x2 = 1; x2 < cw-1; x2 += 2) { var i2 = (y2 * cw + x2) * 4; var gx = ((data[i2+4]||0) - (data[i2-4]||0)) + (((data[i2+4*cw]||0) - (data[i2-4*cw]||0)) * 0.5); var gy = ((data[i2+4*cw]||0) - (data[i2-4*cw]||0)) + (((data[i2+4]||0) - (data[i2-4]||0)) * 0.5); var gmag = Math.sqrt(gx*gx + gy*gy); gradSum += gmag; gradCount++; } }
        var edgeDensity = gradSum / gradCount / 255; var entries = Object.keys(colorCounts).map(function(k){ return { name: k, count: colorCounts[k] }; }); entries.sort(function(a,b){ return b.count - a.count; }); var topColors = entries.filter(function(e){ return e.name !== 'gray' && e.name !== 'white' && e.name !== 'black'; }).slice(0,2); if (topColors.length === 0) topColors = entries.slice(0,1); var tones = topColors.map(function(e){ return e.name; }).join(' and ');
        var bright; if (avgLuma < 0.35) bright = 'dark'; else if (avgLuma > 0.65) bright = 'bright'; else bright = 'neutral'; var vivid; if (colorfulness < 0.12) vivid = 'low colorfulness'; else if (colorfulness > 0.28) vivid = 'high colorfulness'; else vivid = 'moderate colorfulness'; var detail; if (edgeDensity < 0.08) detail = 'low detail'; else if (edgeDensity > 0.20) detail = 'rich detail'; else detail = 'medium detail';
        var parts = []; parts.push('A photo of size ' + w + '×' + h + '.'); if (tones) parts.push('Dominant tones: ' + tones + '.'); parts.push('Overall it looks ' + bright + ' with ' + vivid + ' and ' + detail + '.'); return parts.join(' ');
    }

    async function describeViaWorkflowByFileId(fileId, style){
        async function once() {
            var controller = new AbortController();
            var id = setTimeout(function(){ controller.abort(); }, 60000);
            try {
                var res = await fetch('/api/coze/describer/run', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ image: JSON.stringify({ file_id: fileId }), prompt_style: style }), signal: controller.signal });
                var json;
                try { json = await res.json(); } catch(e){ console.log('[Describer] workflow non-json'); return null; }
                if (!res.ok) { console.log('[Describer] workflow failed', json); return null; }
                if (json && json.text) return json.text;
                var data = json && json.data;
                if (typeof data === 'string') { try { var obj = JSON.parse(data); if (obj && obj.output && typeof obj.output === 'string') return obj.output; if (obj && obj.output && obj.output.text) return obj.output.text; if (obj && obj.text) return obj.text; } catch(e){} }
                else if (data && data.output) { if (typeof data.output === 'string') return data.output; if (data.output.text) return data.output.text; }
                return null;
            } catch(e) { console.log('[Describer] workflow exception', e && e.message); return null; }
            finally { clearTimeout(id); }
        }
        for (var i=0;i<3;i++){ var delay=i===0?0:Math.min(3000, 500*Math.pow(3,i-1)); if(delay) await new Promise(r=>setTimeout(r,delay)); var out=await once(); if (out) return out; }
        return null;
    }

    var btnCloseDescriberModal = document.getElementById('btnCloseDescriberModal');
    var btnDescriberClear = document.getElementById('btnDescriberClear');
    var btnDescriberCopy = document.getElementById('btnDescriberCopy');
    var btnDescriberGenerate = document.getElementById('btnDescriberGenerate');
    var describerStyle = document.getElementById('describerStyle');
    
    btnCloseDescriberModal && btnCloseDescriberModal.addEventListener('click', function(){
        var describerModal = document.getElementById('describerModal');
        if (describerModal) describerModal.style.display = 'none';
    });

    btnDescriberClear && btnDescriberClear.addEventListener('click', function(){
        var describerOutput = document.getElementById('describerOutput');
        if (describerOutput) describerOutput.value = '';
    });

    btnDescriberCopy && btnDescriberCopy.addEventListener('click', function(){
        var describerOutput = document.getElementById('describerOutput');
        var text = describerOutput ? describerOutput.value : '';
        if (text && navigator.clipboard) {
            navigator.clipboard.writeText(text);
            var originalText = this.textContent;
            this.textContent = 'Copied!';
            var btn = this;
            setTimeout(function(){ btn.textContent = originalText; }, 2000);
        }
    });

    btnDescriberGenerate && btnDescriberGenerate.addEventListener('click', async function(){
        var describerOutput = document.getElementById('describerOutput');
        var describerLoading = document.getElementById('describerLoading');
        var describerPreviewImg = document.getElementById('describerPreviewImg');
        
        if (!currentFile && !currentFileId) {
             if (img && img.src && img.src.startsWith('blob:')) { try { var r = await fetch(img.src); currentFile = await r.blob(); } catch(_){} }
             else if (img && img.src && img.src.startsWith('data:')) { try { var arr = img.src.split(','); var mime = arr[0].match(/:(.*?);/)[1]; var bstr = atob(arr[1]); var n = bstr.length; var u8 = new Uint8Array(n); for (var i=0;i<n;i++){ u8[i]=bstr.charCodeAt(i); } var blob = new Blob([u8], { type: mime }); currentFile = new File([blob], 'image.' + (mime.split('/')[1]||'png'), { type: mime }); } catch(_){} }
             if (!currentFile) { alert('No image file available to describe.'); return; }
        }
        
        var btn = this;
        btn.disabled = true;
        if (describerLoading) describerLoading.style.display = 'flex';
        
        try {
            var style = describerStyle ? describerStyle.value : 'Brief';
            var fileId = currentFileId;
            if (!fileId) { fileId = await uploadToServer(currentFile); currentFileId = fileId; }
            
            // Run Workflow
            var desc = await describeViaWorkflowByFileId(fileId, style);
            
            // Fallback
            if (!desc) {
                 desc = analyze(describerPreviewImg);
            }
            
            if (describerOutput) describerOutput.value = desc;
            
        } catch (e) {
            console.error(e);
            alert('Description failed: ' + e.message);
        } finally {
            btn.disabled = false;
            if (describerLoading) describerLoading.style.display = 'none';
        }
    });


    function getCanvasPoint(clientX, clientY) {
      var rect = canvas.getBoundingClientRect();
      var scaleX = canvas.width / rect.width;
      var scaleY = canvas.height / rect.height;
      return {
        x: (clientX - rect.left) * scaleX,
        y: (clientY - rect.top) * scaleY
      };
    }
    
    function hitTest(cx, cy) {
      // cx, cy are Canvas Logical Coordinates
      // Transform to View Space
      var vx = cx - canvas.width/2 - panX;
      var vy = cy - canvas.height/2 - panY;
      
      // Undo View Scale
      var viewScale = baseFitScale * scale;
      vx /= viewScale;
      vy /= viewScale;
      
      // Undo Image Translation
      vx -= imgState.x;
      vy -= imgState.y;
      
      // Undo Image Rotation
      var rad = -imgState.angle * Math.PI / 180;
      var rx = vx * Math.cos(rad) - vy * Math.sin(rad);
      var ry = vx * Math.sin(rad) + vy * Math.cos(rad);
      
      // Undo Image Scale
      rx /= imgState.scale;
      ry /= imgState.scale;
      
      // Check bounds (image is centered at 0,0 in this space, extent is -w/2 to w/2)
      return rx >= -imgW/2 && rx <= imgW/2 && ry >= -imgH/2 && ry <= imgH/2;
    }

    function hitHandle(cx, cy) {
      if (!img || !isSelected) return null;
      var vx = cx - canvas.width/2 - panX;
      var vy = cy - canvas.height/2 - panY;
      var viewScale = baseFitScale * scale;
      vx /= viewScale;
      vy /= viewScale;
      vx -= imgState.x;
      vy -= imgState.y;
      var rad = -imgState.angle * Math.PI / 180;
      var rx = vx * Math.cos(rad) - vy * Math.sin(rad);
      var ry = vx * Math.sin(rad) + vy * Math.cos(rad);
      rx /= imgState.scale;
      ry /= imgState.scale;
      var hw = imgW/2, hh = imgH/2;
      var tol = 12 / (viewScale * imgState.scale);
      var corners = [
        {x:-hw, y:-hh, c:'nw'},
        {x: hw, y:-hh, c:'ne'},
        {x: hw, y: hh, c:'se'},
        {x:-hw, y: hh, c:'sw'}
      ];
      for (var i=0;i<corners.length;i++){
        var h = corners[i];
        if (Math.abs(rx - h.x) <= tol && Math.abs(ry - h.y) <= tol) {
          return { type: 'resize', corner: h.c };
        }
      }
      var rotOffset = 20 / (viewScale * imgState.scale);
      var rdx = rx - 0;
      var rdy = ry - (-hh - rotOffset);
      if (Math.hypot(rdx, rdy) <= tol) {
        return { type: 'rotate' };
      }
      return null;
    }

    canvas && canvas.addEventListener('wheel', function(e){ 
      e.preventDefault(); 
      if (e.ctrlKey) { return; }
      
      if (isSelected && img) {
         // Modify Image
         if (e.altKey) {
            // Rotate (Alt + Scroll)
            var delta = e.deltaY < 0 ? -5 : 5;
            imgState.angle += delta;
         } else {
            // Scale (Scroll or Pinch)
            var delta = e.deltaY < 0 ? 0.05 : -0.05;
            imgState.scale = Math.max(0.1, imgState.scale + delta);
         }
      } else {
         // Modify View (Zoom)
         var delta = e.deltaY < 0 ? 0.1 : -0.1; 
         var old = scale; 
         scale = Math.max(0.1, Math.min(10, scale + delta)); 
         
         // Zoom towards mouse
         var pt = getCanvasPoint(e.clientX, e.clientY);
         var mx = pt.x - canvas.width/2; 
         var my = pt.y - canvas.height/2; 
         
         panX += mx * (scale - old) / old; 
         panY += my * (scale - old) / old; 
         
      }
      draw(); 
    }, { passive: false });

    canvas && canvas.addEventListener('dblclick', function(){ reset(); });
    
    canvas && canvas.addEventListener('mousedown', function(e){
      var pt = getCanvasPoint(e.clientX, e.clientY);
      if (drawMode && img){ 
        drawing = true; 
        var viewScale = baseFitScale * scale;
        var x = (pt.x - canvas.width/2 - panX) / viewScale + imgW/2; 
        var y = (pt.y - canvas.height/2 - panY) / viewScale + imgH/2; 
        if (currentPathLayerIdx == null) { layers.push({ type:'path', name:'Path', visible:true, opacity:1, payload:{ points:[{x:x,y:y}], color:'#2563eb' } }); currentPathLayerIdx = layers.length-1; selectedLayerIdx = currentPathLayerIdx; renderLayersPanel(); }
        else { layers[currentPathLayerIdx].payload.points = [{x:x,y:y}]; }
        draw(); 
        return; 
      }
      
      if (img) {
         var hh = hitHandle(pt.x, pt.y);
         if (hh) {
            isSelected = true;
            toggleSidebar(true);
            var vx = pt.x - canvas.width/2 - panX;
            var vy = pt.y - canvas.height/2 - panY;
            var viewScale = baseFitScale * scale;
            vx /= viewScale; vy /= viewScale;
            vx -= imgState.x; vy -= imgState.y;
            var rad = -imgState.angle * Math.PI / 180;
            var rx = vx * Math.cos(rad) - vy * Math.sin(rad);
            var ry = vx * Math.sin(rad) + vy * Math.cos(rad);
            rx /= imgState.scale; ry /= imgState.scale;
            if (hh.type === 'resize') {
              draggingResize = true;
              dragMeta = { r0: Math.hypot(rx, ry), scale0: imgState.scale, corner: hh.corner };
            } else if (hh.type === 'rotate') {
              draggingRotate = true;
              dragMeta = { theta0: Math.atan2(ry, rx) * 180 / Math.PI, angle0: imgState.angle };
            }
         } else if (hitTest(pt.x, pt.y)) {
            isSelected = true;
            draggingImage = true;
            toggleSidebar(true);
         } else {
            isSelected = false;
            dragging = true;
            draggingImage = false;
            toggleSidebar(false);
         }
      }
      
      lastX = pt.x; 
      lastY = pt.y;
      draw();
    });

    window.addEventListener('mouseup', function(){ var changed = dragging || draggingImage || drawing || draggingResize || draggingRotate; dragging = false; draggingImage = false; drawing = false; draggingResize = false; draggingRotate = false; dragMeta = null; if (changed) pushHistory(); });
    
    window.addEventListener('mousemove', function(e){
      var pt = getCanvasPoint(e.clientX, e.clientY);
      
      var hh = hitHandle(pt.x, pt.y);
      if (img && hh) {
         if (hh.type === 'rotate') {
            canvas.style.cursor = 'crosshair';
         } else if (hh.type === 'resize') {
            if (hh.corner === 'nw' || hh.corner === 'se') canvas.style.cursor = 'nwse-resize';
            else canvas.style.cursor = 'nesw-resize';
         }
      } else if (img && hitTest(pt.x, pt.y)) {
         canvas.style.cursor = drawMode ? 'crosshair' : 'move';
      } else {
         canvas.style.cursor = drawMode ? 'crosshair' : 'default';
      }
      
      if (drawMode && drawing && img){ 
         var viewScale = baseFitScale * scale;
         var x = (pt.x - canvas.width/2 - panX) / viewScale + imgW/2; 
         var y = (pt.y - canvas.height/2 - panY) / viewScale + imgH/2; 
         if (currentPathLayerIdx != null) { layers[currentPathLayerIdx].payload.points.push({x:x,y:y}); }
         draw(); 
         return; 
      }
      
      if (draggingResize && isSelected && dragMeta) {
         var vx = pt.x - canvas.width/2 - panX;
         var vy = pt.y - canvas.height/2 - panY;
         var viewScale = baseFitScale * scale;
         vx /= viewScale; vy /= viewScale;
         vx -= imgState.x; vy -= imgState.y;
         var rad = -imgState.angle * Math.PI / 180;
         var rx = vx * Math.cos(rad) - vy * Math.sin(rad);
         var ry = vx * Math.sin(rad) + vy * Math.cos(rad);
         rx /= imgState.scale; ry /= imgState.scale;
         var r = Math.hypot(rx, ry);
         var ns = dragMeta.scale0 * (r / Math.max(0.0001, dragMeta.r0));
         imgState.scale = Math.max(0.1, Math.min(10, ns));
         draw();
         return;
      }

      if (draggingRotate && isSelected && dragMeta) {
         var vx = pt.x - canvas.width/2 - panX;
         var vy = pt.y - canvas.height/2 - panY;
         var viewScale = baseFitScale * scale;
         vx /= viewScale; vy /= viewScale;
         vx -= imgState.x; vy -= imgState.y;
         var rad = -imgState.angle * Math.PI / 180;
         var rx = vx * Math.cos(rad) - vy * Math.sin(rad);
         var ry = vx * Math.sin(rad) + vy * Math.cos(rad);
         rx /= imgState.scale; ry /= imgState.scale;
         var theta = Math.atan2(ry, rx) * 180 / Math.PI;
         var ang = dragMeta.angle0 + (theta - dragMeta.theta0);
         if (e.shiftKey) {
           ang = Math.round(ang / 15) * 15;
         }
         imgState.angle = ang;
         draw();
         return;
      }

      if (draggingImage && isSelected) {
         // Move Image (imgState.x, y)
         var dx = pt.x - lastX;
         var dy = pt.y - lastY;
         // Convert screen delta to view delta (divide by view scale)
         var viewScale = baseFitScale * scale;
         imgState.x += dx / viewScale;
         imgState.y += dy / viewScale;
         lastX = pt.x;
         lastY = pt.y;
         draw();
         return;
      }
      
      if (dragging) {
         // Pan View
         var dx = pt.x - lastX; 
         var dy = pt.y - lastY; 
         panX += dx; 
         panY += dy; 
         lastX = pt.x; 
         lastY = pt.y; 
         draw();
      }
    });

    function syncToolbar(){
      if (!toolbar || !canvasWrap) return;
      var rect = canvasWrap.getBoundingClientRect();
      var center = rect.top + rect.height / 2;
      toolbar.style.top = center + 'px';
      toolbar.style.transform = 'translateY(-50%)';
    }
    window.addEventListener('resize', function(){ resizeCanvas(); fitBase(); draw(); positionFloatingTools(); });
    window.addEventListener('scroll', function(){ positionFloatingTools(); }, { passive: true });

    ;['gesturestart','gesturechange','gestureend'].forEach(function(evt){
      canvas && canvas.addEventListener(evt, function(e){ e.preventDefault(); }, { passive: false });
      canvasWrap && canvasWrap.addEventListener(evt, function(e){ e.preventDefault(); }, { passive: false });
    });

    ;['dragenter','dragover','dragleave','drop'].forEach(function(evt){ canvasWrap.addEventListener(evt, function(e){ e.preventDefault(); }); });
    canvasWrap.addEventListener('dragover', function(){ canvasWrap.classList.add('dragover'); });
    canvasWrap.addEventListener('dragleave', function(){ canvasWrap.classList.remove('dragover'); });
    canvasWrap.addEventListener('drop', function(e){ canvasWrap.classList.remove('dragover'); var files = e.dataTransfer && e.dataTransfer.files; if (files && files[0]) loadFile(files[0]); });

    var dataUrl = null; try { dataUrl = sessionStorage.getItem('editor:imageData'); } catch(_) {}
    if (dataUrl){ try { sessionStorage.removeItem('editor:imageData'); } catch(_){}; loadDataUrl(dataUrl); }

    resizeCanvas();
    draw();
    positionFloatingTools();
    renderLayersPanel();

    function loadImageLayer(file){ var fr = new FileReader(); fr.onload = function(){ var im = new Image(); im.onload = function(){ layers.push({ type:'image', name:'Image', visible:true, opacity:1, payload:{ image:im, w:im.naturalWidth, h:im.naturalHeight, x:imgW/2, y:imgH/2 } }); selectedLayerIdx = layers.length-1; draw(); renderLayersPanel(); pushHistory(); }; im.src = fr.result; }; fr.readAsDataURL(file); }

    function renderLayersPanel(){ 
      var list = document.getElementById('layersList'); 
      if (!list) return; 
      list.innerHTML=''; 
      
      // Update opacity display for selected layer
      var opacityDisplay = document.getElementById('layerOpacityDisplay');
      if (opacityDisplay && selectedLayerIdx != null && layers[selectedLayerIdx]) {
        var val = layers[selectedLayerIdx].opacity;
        opacityDisplay.textContent = Math.round((typeof val === 'number' ? val : 1) * 100) + ' %';
      } else if (opacityDisplay) {
        opacityDisplay.textContent = '-';
      }

      var imageLayers = [];
      for (var i=layers.length-1; i>=0; i--) {
        if (layers[i].type === 'image') imageLayers.push({layer: layers[i], idx: i});
      }

      if (imageLayers.length === 0) {
        var empty = document.createElement('div');
        empty.style.padding = '16px';
        empty.style.textAlign = 'center';
        empty.style.color = '#9ca3af';
        empty.style.fontSize = '0.875rem';
        empty.textContent = 'No image layers';
        list.appendChild(empty);
        return;
      }

      imageLayers.forEach(function(item){
        var L = item.layer;
        var idx = item.idx;
        
        var row = document.createElement('div');
        row.className = 'layer-item' + (selectedLayerIdx===idx ? ' selected' : '');
        
        // Thumbnail
        var thumb = document.createElement('img');
        thumb.className = 'layer-thumb';
        if (L.payload && L.payload.image) {
          thumb.src = L.payload.image.src;
        }
        
        // Info
        var info = document.createElement('div');
        info.className = 'layer-info';
        var name = document.createElement('div');
        name.className = 'layer-name';
        name.textContent = L.name || 'Image Layer ' + idx;
        info.appendChild(name);
        
        // Actions
        var actions = document.createElement('div');
        actions.className = 'layer-actions';
        
        var btnVis = document.createElement('button');
        btnVis.className = 'layer-action-btn';
        btnVis.innerHTML = L.visible 
          ? '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg>'
          : '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path><line x1="1" y1="1" x2="23" y2="23"></line></svg>';
        btnVis.onclick = function(e){ 
          e.stopPropagation();
          L.visible = !L.visible; 
          draw(); 
          renderLayersPanel(); 
          pushHistory(); 
        };
        
        actions.appendChild(btnVis);
        
        row.onclick = function(){ 
          selectedLayerIdx = idx; 
          renderLayersPanel(); 
        };
        
        row.appendChild(thumb);
        row.appendChild(info);
        row.appendChild(actions);
        list.appendChild(row);
      });
    }

    function mergeLayers(opts){ if (!img) return; var mode = (opts && opts.mode) || 'visible'; var sel = []; if (mode==='visible'){ for (var i=0;i<layers.length;i++){ if (layers[i].visible) sel.push(i); } } else if (mode==='selected'){ if (selectedLayerIdx!=null) sel.push(selectedLayerIdx); }
      var oc = document.createElement('canvas'); oc.width = imgW; oc.height = imgH; var octx = oc.getContext('2d'); octx.clearRect(0,0,oc.width,oc.height);
      // base image
      octx.save(); octx.globalAlpha = 1; octx.drawImage(img, 0, 0, imgW, imgH); octx.restore();
      // layers in natural image coords
      for (var k=0;k<sel.length;k++){ var L = layers[sel[k]]; if (!L.visible) continue; var alpha = typeof L.opacity==='number'?L.opacity:1; octx.save(); octx.globalAlpha = alpha; if (L.type==='board'){ octx.fillStyle = (L.payload && L.payload.bgColor) || '#ffffff'; octx.fillRect(0,0,imgW,imgH); } else if (L.type==='text'){ var t=L.payload||{}; octx.fillStyle = t.color || '#111827'; octx.font = t.font || '16px Inter, sans-serif'; octx.textAlign='center'; octx.textBaseline='middle'; octx.fillText(t.text||'Text', t.x||imgW/2, t.y||imgH/2); } else if (L.type==='path'){ var pts=(L.payload&&L.payload.points)||[]; if (pts.length>=2){ octx.strokeStyle = (L.payload && L.payload.color) || '#2563eb'; octx.beginPath(); for (var j=0;j<pts.length;j++){ var p=pts[j]; if (j===0) octx.moveTo(p.x,p.y); else octx.lineTo(p.x,p.y); } octx.stroke(); } } else if (L.type==='image'){ var im=L.payload&&L.payload.image; var w=L.payload&&L.payload.w; var h=L.payload&&L.payload.h; var x0=L.payload&&L.payload.x; var y0=L.payload&&L.payload.y; if (im && w && h && x0!=null && y0!=null){ octx.drawImage(im, x0 - w/2, y0 - h/2, w, h); } } octx.restore(); }
      try { var mergedUrl = oc.toDataURL('image/png'); loadDataUrl(mergedUrl); } catch(e) { alert('Merge failed'); }
    }

    function cloneLayers(){ var out = []; for (var i=0;i<layers.length;i++){ var L = layers[i]; var P = L.payload ? JSON.parse(JSON.stringify(L.payload, function(k,v){ return v; })) : null; if (L.type==='image' && L.payload && L.payload.image){ if (!P) P={}; P.image = L.payload.image; } out.push({ type:L.type, name:L.name, visible:L.visible, opacity:L.opacity, locked:L.locked, payload:P }); } return out; }
    function snapshot(){ return { imgState: { x: imgState.x, y: imgState.y, scale: imgState.scale, angle: imgState.angle }, scale: scale, panX: panX, panY: panY, layers: cloneLayers() }; }
    function applySnapshot(s){ if (!s) return; imgState = { x: s.imgState.x, y: s.imgState.y, scale: s.imgState.scale, angle: s.imgState.angle }; scale = s.scale; panX = s.panX; panY = s.panY; layers = s.layers || []; selectedLayerIdx = null; currentPathLayerIdx = null; draw(); renderLayersPanel(); positionFloatingTools(); }
    function pushHistory(){ history.push(snapshot()); future = []; }
    function undo(){ if (history.length<=1) return; var cur = snapshot(); var prev = history.pop(); var state = history[history.length-1]; future.push(cur); applySnapshot(state); }
    function redo(){ if (!future.length) return; var cur = snapshot(); var next = future.pop(); history.push(next); applySnapshot(next); }

    function deleteImage(){ if (!img) return; img = null; imgW = 0; imgH = 0; layers = []; selectedLayerIdx = null; currentPathLayerIdx = null; scale = 1; panX = 0; panY = 0; imgState = { x: 0, y: 0, scale: 1, angle: 0 }; isSelected = false; isProcessing = false; if (emptyState) emptyState.style.display = 'block'; draw(); renderLayersPanel(); }

    btnUndo && btnUndo.addEventListener('click', function(){ undo(); });
    btnRedo && btnRedo.addEventListener('click', function(){ redo(); });
    btnZoomIn && btnZoomIn.addEventListener('click', function(){ scale = Math.min(10, scale + 0.1); draw(); positionFloatingTools(); pushHistory(); });
    btnZoomOut && btnZoomOut.addEventListener('click', function(){ scale = Math.max(0.1, scale - 0.1); draw(); positionFloatingTools(); pushHistory(); });
    btnShowLayers && btnShowLayers.addEventListener('click', function(e){ 
      e.stopPropagation();
      var pop = document.getElementById('layerPopover'); 
      if (pop){ 
        var isVis = pop.style.display !== 'none';
        pop.style.display = isVis ? 'none' : 'flex';
        if (!isVis) renderLayersPanel();
      } 
    });
    window.addEventListener('click', function(e){
      var pop = document.getElementById('layerPopover');
      if (pop && pop.style.display !== 'none' && !pop.contains(e.target) && btnShowLayers && !btnShowLayers.contains(e.target)){
        pop.style.display = 'none';
      }
    });

    var btnFitScreen = document.getElementById('btnFitScreen');
    btnFitScreen && btnFitScreen.addEventListener('click', function(){
      if (!img) return;
      fitBase();
      scale = 1; 
      panX = 0; panY = 0;
      draw();
      positionFloatingTools();
      pushHistory();
    });

    window.addEventListener('keydown', function(e){ if ((e.key==='Delete' || e.key==='Backspace') && img){ e.preventDefault(); deleteImage(); } });
  })();
  </script>
</body>
</html>
